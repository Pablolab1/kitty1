{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  Appearance: true,\n  AppearanceProvider: true,\n  useColorScheme: true\n};\nexports.AppearanceProvider = exports.Appearance = void 0;\nexports.useColorScheme = useColorScheme;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _fbemitter = require(\"fbemitter\");\n\nvar _useSubscription = require(\"use-subscription\");\n\nvar _Appearance = require(\"./Appearance.types\");\n\nObject.keys(_Appearance).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _Appearance[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Appearance[key];\n    }\n  });\n});\n\nvar _NativeAppearance = require(\"./NativeAppearance\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar _jsxFileName = \"/Users/brentvatne/code/react-native-appearance/src/index.tsx\";\nvar eventEmitter = new _fbemitter.EventEmitter();\nvar appearancePreferences = _NativeAppearance.NativeAppearance.initialPreferences;\nvar nativeEventEmitter = new _reactNative.NativeEventEmitter(_NativeAppearance.NativeAppearance);\nnativeEventEmitter.addListener('appearanceChanged', function (newAppearance) {\n  Appearance.set(newAppearance);\n});\n\nvar Appearance = function () {\n  function Appearance() {\n    (0, _classCallCheck2.default)(this, Appearance);\n  }\n\n  (0, _createClass2.default)(Appearance, null, [{\n    key: \"getColorScheme\",\n    value: function getColorScheme() {\n      return appearancePreferences.colorScheme;\n    }\n  }, {\n    key: \"set\",\n    value: function set(preferences) {\n      var colorScheme = preferences.colorScheme;\n\n      if (appearancePreferences.colorScheme !== colorScheme) {\n        appearancePreferences = {\n          colorScheme: colorScheme\n        };\n        eventEmitter.emit('change', preferences);\n      }\n    }\n  }, {\n    key: \"addChangeListener\",\n    value: function addChangeListener(listener) {\n      return eventEmitter.addListener('change', listener);\n    }\n  }]);\n  return Appearance;\n}();\n\nexports.Appearance = Appearance;\n\nvar AppearanceProvider = function AppearanceProvider(props) {\n  return _react.default.createElement(_NativeAppearance.NativeAppearanceProvider, (0, _extends2.default)({\n    style: {\n      flex: 1\n    }\n  }, props, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 70\n    }\n  }));\n};\n\nexports.AppearanceProvider = AppearanceProvider;\n\nfunction useColorScheme() {\n  var subscription = (0, _react.useMemo)(function () {\n    return {\n      getCurrentValue: function getCurrentValue() {\n        return Appearance.getColorScheme();\n      },\n      subscribe: function subscribe(callback) {\n        var eventSubscription = Appearance.addChangeListener(callback);\n        return function () {\n          return eventSubscription.remove();\n        };\n      }\n    };\n  }, []);\n  return (0, _useSubscription.useSubscription)(subscription);\n}","map":{"version":3,"sources":["index.tsx"],"names":["eventEmitter","appearancePreferences","NativeAppearance","nativeEventEmitter","Appearance","colorScheme","preferences","AppearanceProvider","flex","subscription","useMemo","getCurrentValue","subscribe","eventSubscription","useSubscription"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;AAAA;EAAA;EAAA;EAAA;EAAA;IAAA;IAAA;MAAA;IAAA;EAAA;AAAA;;AAGA;;;;;;;AAGA,IAAMA,YAAY,GAAG,IAArB,uBAAqB,EAArB;AAGA,IAAIC,qBAA4C,GAAGC,kCAAAA,CAAnD,kBAAA;AAGA,IAAMC,kBAAkB,GAAG,IAAA,+BAAA,CAA3B,kCAA2B,CAA3B;AACAA,kBAAkB,CAAlBA,WAAAA,CAAAA,mBAAAA,EAAoD,UAAA,aAAA,EAA0C;EAC5FC,UAAU,CAAVA,GAAAA,CAAAA,aAAAA;AADFD,CAAAA;;AAIA,IAAaC,UAAb,GAAA,YAAA;EAAA,SAAA,UAAA,GAAA;IAAA,IAAA,wBAAA,EAAA,IAAA,EAAA,UAAA;EAAA;;EAAA,IAAA,qBAAA,EAAA,UAAA,EAAA,IAAA,EAAA,CAAA;IAAA,GAAA,EAAA,gBAAA;IAAA,KAAA,EAAA,SAAA,cAAA,GAa2C;MACvC,OAAOH,qBAAqB,CAA5B,WAAA;IAdJ;EAAA,CAAA,EAAA;IAAA,GAAA,EAAA,KAAA;IAAA,KAAA,EAAA,SAAA,GAAA,CAAA,WAAA,EAwBuD;MAAA,IAC7CI,WAD6C,GAC7BC,WAD6B,CAAA,WAAA;;MAInD,IAAIL,qBAAqB,CAArBA,WAAAA,KAAJ,WAAA,EAAuD;QACrDA,qBAAqB,GAAG;UAAEI,WAAW,EAArCJ;QAAwB,CAAxBA;QACAD,YAAY,CAAZA,IAAAA,CAAAA,QAAAA,EAAAA,WAAAA;MAEH;IAhCH;EAAA,CAAA,EAAA;IAAA,GAAA,EAAA,mBAAA;IAAA,KAAA,EAAA,SAAA,iBAAA,CAAA,QAAA,EAqC4E;MACxE,OAAOA,YAAY,CAAZA,WAAAA,CAAAA,QAAAA,EAAP,QAAOA,CAAP;IAtCJ;EAAA,CAAA,CAAA;EAAA,OAAA,UAAA;AAAA,CAAA,EAAA;;;;AA8CO,IAAMO,kBAAkB,GAAlBA,SAAAA,kBAAAA,CAAqB,KAArBA,EAAqB;EAAA,OAChC,cAAA,CAAA,aAAA,CAAA,0CAAA,EAAA,IAAA,iBAAA,EAAA;IAA0B,KAAK,EAAE;MAAEC,IAAI,EAAvC;IAAiC;EAAjC,CAAA,EAAA,KAAA,EAAA;IAAA,QAAA,EAAA;MAAA,QAAA,EAAA,YAAA;MAAA,UAAA,EADgC;IAChC;EAAA,CAAA,CAAA,CADgC;AAA3B,CAAA;;;;AAOA,SAAA,cAAA,GAA2C;EAChD,IAAMC,YAAY,GAAGC,IAAAA,cAAAA,EACnB,YAAA;IAAA,OAAO;MACLC,eAAe,EAAE,SAAA,eAAA,GAAA;QAAA,OAAMP,UAAU,CAAhB,cAAMA,EAAN;MADZ,CAAA;MAELQ,SAAS,EAAE,SAAA,SAAA,CAAA,QAAA,EAAkC;QAC3C,IAAIC,iBAAiB,GAAGT,UAAU,CAAVA,iBAAAA,CAAxB,QAAwBA,CAAxB;QACA,OAAO,YAAA;UAAA,OAAMS,iBAAiB,CAAvB,MAAMA,EAAN;QAAP,CAAA;MAJJ;IAAO,CAAP;EAD0B,CAAPH,EAArB,EAAqBA,CAArB;EAWA,OAAOI,IAAAA,gCAAAA,EAAP,YAAOA,CAAP;AACD","sourcesContent":["import React, { useMemo } from 'react';\nimport { NativeEventEmitter } from 'react-native';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport { useSubscription } from 'use-subscription';\nimport { AppearancePreferences, ColorSchemeName, AppearanceListener } from './Appearance.types';\nexport * from './Appearance.types';\n\n// Native modules\nimport { NativeAppearance, NativeAppearanceProvider } from './NativeAppearance';\n\n// Initialize the user-facing event emitter\nconst eventEmitter = new EventEmitter();\n\n// Initialize preferences synchronously\nlet appearancePreferences: AppearancePreferences = NativeAppearance.initialPreferences;\n\n// Initialize the native event emitter\nconst nativeEventEmitter = new NativeEventEmitter(NativeAppearance);\nnativeEventEmitter.addListener('appearanceChanged', (newAppearance: AppearancePreferences) => {\n  Appearance.set(newAppearance);\n});\n\nexport class Appearance {\n  /**\n   * Note: Although appearance is available immediately, it may change (e.g\n   * Dark Mode) so any rendering logic or styles that depend on this should try\n   * to call this function on every render, rather than caching the value (for\n   * example, using inline styles rather than setting a value in a\n   * `StyleSheet`).\n   *\n   * Example: `const colorScheme = Appearance.get('colorScheme');`\n   *\n   * @param {string} preference Name of preference (e.g. 'colorScheme').\n   * @returns {ColorSchemeName} Value for the preference.\n   */\n  static getColorScheme(): ColorSchemeName {\n    return appearancePreferences.colorScheme;\n  }\n\n  /**\n   * This should only be called from native code by sending the\n   * appearanceChanged event.\n   *\n   * @param {object} appearancePreferences Simple string-keyed object of\n   * appearance preferences to set.\n   */\n  static set(preferences: AppearancePreferences): void {\n    let { colorScheme } = preferences;\n\n    // Don't bother emitting if it's the same value\n    if (appearancePreferences.colorScheme !== colorScheme) {\n      appearancePreferences = { colorScheme };\n      eventEmitter.emit('change', preferences);\n    }\n  }\n\n  /**\n   * Add an event handler that is fired when appearance preferences change.\n   */\n  static addChangeListener(listener: AppearanceListener): EventSubscription {\n    return eventEmitter.addListener('change', listener);\n  }\n}\n\n/**\n * Temporarily require a Provider since the upstream implementation uses root view customizations\n * to accomplish this same behavior\n */\nexport const AppearanceProvider = (props: { children: any }) => (\n  <NativeAppearanceProvider style={{ flex: 1 }} {...props} />\n);\n\n/**\n * Subscribe to color scheme updates\n */\nexport function useColorScheme(): ColorSchemeName {\n  const subscription = useMemo(\n    () => ({\n      getCurrentValue: () => Appearance.getColorScheme(),\n      subscribe: (callback: AppearanceListener) => {\n        let eventSubscription = Appearance.addChangeListener(callback);\n        return () => eventSubscription.remove();\n      },\n    }),\n    [],\n  );\n\n  return useSubscription<ColorSchemeName>(subscription);\n}\n"]},"metadata":{},"sourceType":"script"}